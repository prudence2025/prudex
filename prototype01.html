<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Factory X Main Dashboard</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;900&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- ## MODIFICATION: Added libraries for advanced chart handling and CSV parsing ## -->
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.0/papaparse.min.js"></script>
    <style>
        /* Base styles for the body */
        body {
            font-family: 'Inter', sans-serif;
            color: #333;
            text-align: center;
            padding: 20px;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            background-image: url("https://prudenceeng.lk/wp-content/uploads/2025/08/download.jpg"); 
            background-size: cover; 
            background-position: center; 
            background-attachment: fixed;
        }
        
        /* Styling for the main heading */
        h1 {
            margin-bottom: 30px;
        }

        /* Header styling */
        header {
            background: rgba(255, 255, 255, 0.5);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.7);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            border-radius: 15px;
            padding: 15px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 40px;
            position: relative;
            z-index: 10;
        }
        .header-title {
            font-family: 'Inter', sans-serif;
            font-size: 1.8rem;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 1px;
            background: linear-gradient(to right, #007bff, #00d4ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            color: transparent;
            margin-right: 40px;
        }


        .nav-button {
            background-color: #007bff;
            color: white;
            padding: 8px 15px;
            border-radius: 8px;
            font-weight: 600;
            transition: background-color 0.2s ease-in-out;
            cursor: pointer;
        }
        .nav-button:hover {
            background-color: #0056b3;
        }
        .dropdown {
            position: relative;
        }
        .dropdown-content {
            display: none;
            position: absolute;
            background-color: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(8px);
            min-width: 200px;
            box-shadow: 0 8px 16px 0 rgba(0,0,0,0.2);
            z-index: 20;
            border-radius: 8px;
            overflow: hidden;
            margin-top: 10px;
            left: 0;
            top: 100%;
        }
        .dropdown-content.show {
            display: block;
        }
        .dropdown-content a {
            color: #333;
            padding: 12px 16px;
            text-decoration: none;
            display: block;
            text-align: left;
            transition: background-color 0.2s ease-in-out;
            cursor: pointer;
        }
        .dropdown-content a:hover {
            background-color: #f1f1f1;
        }

        /* Glassy effect for the data panels */
        .glass-panel {
            background: rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.5);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.1);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 25px;
        }

        /* ## MODIFICATION: Updated gauge styles for conic-gradient design ## */
        .gauge-card {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.5);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.1);
            border-radius: 15px;
            padding: 30px;
            margin: 15px;
            min-width: 180px;
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            text-align: center;
            flex: 1 1 calc(20% - 30px);
            max-width: calc(20% - 30px);
            box-sizing: border-box;
        }
        .gauge-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 12px 48px 0 rgba(0, 0, 0, 0.15);
        }
        .gauge-container {
            position: relative;
            width: 180px;
            height: 180px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 10px;
        }
        .gauge-fill {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: conic-gradient(var(--fill-color, #e2e8f0) 0deg, #e2e8f0 0deg);
            transition: background 0.5s ease-in-out;
        }
        .gauge-inner-circle {
            position: absolute;
            width: 135px;
            height: 135px;
            border-radius: 50%;
            background-color: rgba(240, 242, 245, 0.8);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2;
        }
        .gauge-value {
            font-size: 1.5rem;
            font-weight: bold;
        }
        .gauge-label {
            font-size: 1.1em;
            color: #555;
            margin-top: 5px;
            font-weight: 600;
        }
        .gauge-unit {
            font-size: 0.9em;
            color: #777;
            font-weight: normal;
        }

        /* ## MODIFICATION: New gauge color classes ## */
        .gauge-green {
            --fill-color: #10b981 !important;
        }
        .gauge-orange {
            --fill-color: #f97316 !important;
        }

        /* ## MODIFICATION: Updated gauges container for 5 per line layout ## */
        #gauges-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: center;
            align-items: stretch;
            width: 100%;
        }

        /* ## MODIFICATION: Updated device status container for 5 per line layout ## */
        #device-status-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: center;
            align-items: stretch;
            width: 100%;
        }

        /* Device status card styling */
        .device-card {
            background: rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.5);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.1);
            border-radius: 15px;
            padding: 25px;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            text-align: left;
            position: relative;
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            cursor: pointer;
            flex: 1 1 calc(20% - 20px);
            max-width: calc(20% - 20px);
            box-sizing: border-box;
            margin: 10px;
        }
        .device-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 12px 48px 0 rgba(0, 0, 0, 0.15);
        }
        .device-name {
            font-size: 1.1em;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 5px;
        }
        .value-display {
            font-size: 1.5em;
            font-weight: bold;
            color: #333;
            margin-top: 5px;
        }
        .disconnected-text {
            font-size: 1.3em;
            font-weight: bold;
            color: #dc2626;
            margin-top: 5px;
        }

        /* Login page styles */
        .login-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.15);
            max-width: 400px;
            width: 90%;
            margin: auto;
            position: relative;
            z-index: 1;
        }
        .login-input {
            width: 100%;
            padding: 12px 15px;
            margin-bottom: 15px;
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 8px;
            font-size: 1.1em;
            background-color: rgba(255, 255, 255, 0.8);
            color: #333;
        }
        .login-button {
            width: 100%;
            padding: 12px 20px;
            background-color: #007bff;
            color: white;
            border-radius: 8px;
            font-weight: bold;
            font-size: 1.1em;
            transition: background-color 0.2s ease-in-out;
            cursor: pointer;
        }
        .login-button:hover {
            background-color: #0056b3;
        }
        .login-error {
            color: #dc2626;
            margin-top: 10px;
            font-weight: 600;
        }
        .login-title {
            font-family: 'Inter', sans-serif;
            font-size: 3rem;
            font-weight: 900;
            margin-bottom: 25px;
            text-transform: uppercase;
            letter-spacing: 2px;
            background: linear-gradient(to right, #007bff, #00d4ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            color: transparent;
        }
        .hidden {
            display: none;
        }

        /* ## MODIFICATION: New modal styles inspired by the provided file ## */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(5px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
        }
        .modal-overlay.show {
            opacity: 1;
            visibility: visible;
        }
        .modal-content {
            background: white;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 5px 25px rgba(0, 0, 0, 0.2);
            width: 90%;
            max-width: 800px;
            transform: scale(0.95);
            transition: transform 0.3s;
        }
        /* Futuristic chat styles */
        .chat-surface {
            background: radial-gradient(1200px 600px at 10% -10%, rgba(59,130,246,0.08), transparent 60%),
                        radial-gradient(1200px 600px at 110% 110%, rgba(20,184,166,0.08), transparent 60%);
            border: 1px solid rgba(0,0,0,0.06);
        }
        .chat-bubble {
            position: relative;
            border: 1px solid rgba(255,255,255,0.35);
            box-shadow: 0 10px 25px rgba(0,0,0,0.06), inset 0 0 15px rgba(255,255,255,0.08);
            backdrop-filter: blur(6px);
        }
        .chat-bubble-user {
            background: linear-gradient(135deg, rgba(59,130,246,0.16), rgba(59,130,246,0.06));
            border-color: rgba(59,130,246,0.35);
            color: #0b3b7a;
        }
        .chat-bubble-assistant {
            background: linear-gradient(135deg, rgba(16,185,129,0.16), rgba(16,185,129,0.06));
            border-color: rgba(16,185,129,0.35);
            color: #064e3b;
        }
        .chat-meta {
            display: block;
            font-size: 0.72rem;
            opacity: 0.7;
            margin-top: 6px;
        }
        .typing-dots {
            display: inline-flex;
            gap: 4px;
            vertical-align: middle;
        }
        .typing-dots span {
            width: 6px;
            height: 6px;
            border-radius: 9999px;
            background: #10b981;
            opacity: 0.3;
            animation: blink 1.2s infinite ease-in-out;
        }
        .typing-dots span:nth-child(2) { animation-delay: 0.2s; }
        .typing-dots span:nth-child(3) { animation-delay: 0.4s; }
        @keyframes blink { 0%, 80%, 100% { opacity: 0.2; } 40% { opacity: 1; } }
        .modal-overlay.show .modal-content {
            transform: scale(1);
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #e5e7eb;
            padding-bottom: 15px;
            margin-bottom: 15px;
        }
        .modal-title {
            font-size: 1.5rem;
            font-weight: 700;
            color: #333;
        }
        .modal-close-button {
            background: none;
            border: none;
            font-size: 1.8rem;
            cursor: pointer;
            color: #555;
            transition: color 0.2s;
        }
        .modal-close-button:hover {
            color: #000;
        }
        .filter-buttons {
            text-align: center;
            margin-bottom: 1rem;
        }
        .filter-buttons button {
            background-color: #e5e7eb;
            color: #374151;
            padding: 8px 16px;
            margin: 0 5px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s, color 0.2s;
        }
        .filter-buttons button:hover {
            background-color: #d1d5db;
        }
        .filter-buttons button.active {
            background-color: #007bff;
            color: white;
        }
        .alerts-button {
            background-color: #dc2626 !important;
            color: white !important;
            position: relative;
            font-weight: 700;
            box-shadow: 0 2px 4px rgba(220, 38, 38, 0.3);
            transition: all 0.3s ease;
        }
        .alerts-button:hover {
            background-color: #b91c1c !important;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(220, 38, 38, 0.4);
        }
        .alerts-button.active {
            background-color: #991b1b !important;
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(220, 38, 38, 0.5);
        }

        /* ## MODIFICATION: Responsive breakpoints for 5-per-line layout ## */
        @media (max-width: 1400px) {
            .gauge-card {
                flex: 1 1 calc(25% - 22.5px);
                max-width: calc(25% - 22.5px);
            }
            .device-card {
                flex: 1 1 calc(25% - 15px);
                max-width: calc(25% - 15px);
            }
        }

        @media (max-width: 1100px) {
            .gauge-card {
                flex: 1 1 calc(33.33% - 20px);
                max-width: calc(33.33% - 20px);
            }
            .device-card {
                flex: 1 1 calc(33.33% - 13.33px);
                max-width: calc(33.33% - 13.33px);
            }
        }

        @media (max-width: 768px) {
            .gauge-card {
                flex: 1 1 calc(50% - 15px);
                max-width: calc(50% - 15px);
            }
            .device-card {
                flex: 1 1 calc(50% - 10px);
                max-width: calc(50% - 10px);
            }
        }

        @media (max-width: 480px) {
            .gauge-card {
                flex: 1 1 100%;
                max-width: 100%;
            }
            .device-card {
                flex: 1 1 100%;
                max-width: 100%;
            }
        }
    </style>
</head>
<body>
    <div id="login-page" class="login-container">
        <h2 class="login-title">PrudeX</h2>
        <input type="text" id="username" placeholder="Username" class="login-input">
        <input type="password" id="password" placeholder="Password" class="login-input">
        <button id="login-button" class="login-button">Login</button>
        <p id="login-error-message" class="login-error hidden"></p>
    </div>

    <div id="dashboard-content" class="hidden flex-grow flex flex-col items-center">
        <header>
            <div class="header-title">Factory X</div>
            <div class="flex space-x-10 items-center">
                <div class="relative dropdown">
                    <button id="dashboard-nav-button" class="nav-button">Dashboard</button>
                    <div id="dashboard-dropdown-content" class="dropdown-content">
                        <a href="#" class="dropdown-item" data-dashboard="main">Factory X Main Dashboard</a>
                        <a href="#" class="dropdown-item" data-dashboard="kandy">Factory X Kandy</a>
                        <a href="#" class="dropdown-item" data-dashboard="galle">Factory X Galle</a>
                    </div>
                </div>
                <div class="relative dropdown">
                    <button id="download-nav-button" class="nav-button">Download</button>
                    <div id="download-dropdown-content" class="dropdown-content">
                        <a href="https://api.prudex.net/download" target="_blank" class="dropdown-item">Factory X Kandy</a>
                        <a href="https://api1.prudex.net/download" target="_blank" class="dropdown-item">Factory X Galle</a>
                        <a href="https://api2.prudex.net/download" target="_blank" class="dropdown-item">Factory X Conductivity</a>
                    </div>
                </div>
                <button id="ask-prudex-button" class="nav-button">Ask PrudeX</button>
                <button id="logout-button" class="nav-button">Logout</button>
            </div>

        </header>

        <div class="container mx-auto p-4 max-w-7xl mt-16">
            <h1 id="dashboard-main-title" class="text-4xl font-extrabold text-transparent bg-clip-text bg-gradient-to-r from-blue-600 to-cyan-500 mb-16">
                 Factory X Main Dashboard
            </h1>

            <div class="glass-panel">
                <div id="device-status-container">
                </div>
            </div>

            <div class="glass-panel">
                <div id="gauges-container">
                </div>
            </div>
        </div>
    </div>

    <!-- ## MODIFICATION: Replaced old modal with new design ## -->
    <div id="history-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modal-title" class="modal-title">Historical Data</h2>
                <button id="modal-close-button" class="modal-close-button">&times;</button>
            </div>
            <div class="modal-body">
                <div class="filter-buttons">
                    <button data-hours="1" class="active">1 Hour</button>
                    <button data-days="1">1 Day</button>
                    <button data-days="7">7 Days</button>
                    <button data-days="30">30 Days</button>
                    <button id="alerts-button" class="alerts-button" title="Show only data points that are out of normal range (warnings and alerts)">Alerts</button>
                </div>
                <!-- Editable alert thresholds -->
                <div id="alert-threshold-editor" style="display:flex; gap:10px; align-items:center; justify-content:center; margin-bottom:10px;">
                    <label for="alert-min" style="font-weight:600;">Min</label>
                    <input id="alert-min" type="number" step="0.01" placeholder="min (optional)" class="login-input" style="max-width:140px; margin:0;"/>
                    <label for="alert-max" style="font-weight:600;">Max</label>
                    <input id="alert-max" type="number" step="0.01" placeholder="max (optional)" class="login-input" style="max-width:140px; margin:0;"/>
                    <button id="apply-alert-thresholds" class="login-button" style="width:auto; padding:8px 14px;">Apply</button>
                    <span style="font-weight:600; color:#374151;">Safe Range</span>
                    <button id="clear-alert-thresholds" class="login-button" style="width:auto; padding:8px 14px; background-color:#6b7280;">Clear</button>
                </div>
                <canvas id="history-chart"></canvas>
            </div>
        </div>
    </div>

    <!-- Ask PrudeX Modal -->
    <div id="ask-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Ask PrudeX</h2>
                <button id="ask-close-button" class="modal-close-button">&times;</button>
            </div>
            <div class="modal-body">
                <div id="ask-chat" class="glass-panel chat-surface" style="max-height: 420px; overflow-y: auto; text-align: left; padding: 16px;"></div>
                <div class="mb-4" style="display:flex; gap: 8px; align-items: center; margin-top: 12px;">
                    <input id="ask-input" type="text" placeholder="Ask anything about your data..." class="login-input" style="flex:1; margin:0; height: 44px; border:1px solid rgba(59,130,246,0.3);" />
                    <button id="ask-submit" class="login-button" style="margin:0; width: auto; min-width: 84px; padding: 10px 16px; font-size: 14px; background: linear-gradient(135deg, #3b82f6, #06b6d4);">Ask</button>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        const backendUrlMain = "https://api.prudex.net/latest";
        const backendUrlGalle = "https://api1.prudex.net/latest";
        const backendUrlConductivity = "https://api2.prudex.net/latest";

        // DOM element references
        const loginPage = document.getElementById("login-page");
        const dashboardContent = document.getElementById("dashboard-content");
        const loginButton = document.getElementById("login-button");
        const logoutButton = document.getElementById("logout-button");
        const usernameInput = document.getElementById("username");
        const passwordInput = document.getElementById("password");
        const loginErrorMessage = document.getElementById("login-error-message");

        const dashboardMainTitle = document.getElementById("dashboard-main-title");
        const deviceStatusContainer = document.getElementById("device-status-container");
        const gaugesContainer = document.getElementById("gauges-container");

        const downloadNavButton = document.getElementById("download-nav-button");
        const downloadDropdownContent = document.getElementById("download-dropdown-content");
        const dashboardNavButton = document.getElementById("dashboard-nav-button");
        const dashboardDropdownContent = document.getElementById("dashboard-dropdown-content");
        const dropdownItems = document.querySelectorAll(".dropdown-item");
        const askPrudexButton = document.getElementById("ask-prudex-button");
        
        // ## MODIFICATION: Updated modal and chart elements ##
        const historyModal = document.getElementById("history-modal");
        const modalCloseButton = document.getElementById('modal-close-button');
        const modalTitle = document.getElementById("modal-title");
        const filterButtons = document.querySelectorAll('.filter-buttons button');
        let historyChart = null;
        let historicalData = []; // To store parsed CSV data
        let isAlertsMode = false; // Track if alerts mode is active
        let customAlertMin = null; // Custom thresholds from editor (active)
        let customAlertMax = null;
        const customThresholds = {}; // per-parameter saved thresholds: { [paramId]: { min, max } }

        // Ask PrudeX elements
        const askModal = document.getElementById('ask-modal');
        const askCloseButton = document.getElementById('ask-close-button');
        const askInput = document.getElementById('ask-input');
        const askSubmit = document.getElementById('ask-submit');
        const askChat = document.getElementById('ask-chat');

        let currentDashboardView = "main";
        let fetchDataInterval;



        const maxValues = {
            temperature: 50,
            cod: 500,
            bod: 300,
            tss: 300,
            turbidity: 1000,
            ph: 14,
            conductivity: 50000
        };

        // ## MODIFICATION: Added warning/danger limits for gauge colors ##
        const parameterInfo = {
            temperature: { id: "temperature", label: "Temperature", unit: "°C", limits: { warning: 30, danger: 35 } },
            cod: { id: "cod", label: "COD", unit: "mg/L", limits: { warning: 100, danger: 250 } },
            bod: { id: "bod", label: "BOD", unit: "mg/L", limits: { warning: 40, danger: 100 } },
            tss: { id: "tss", label: "TSS", unit: "mg/L", limits: { warning: 50, danger: 150 } },
            turbidity: { id: "turbidity", label: "Turbidity", unit: "NTU", limits: { warning: 5, danger: 50 } },
            ph: { id: "ph", label: "pH", unit: "", limits: { warning: 8.5, danger: 9.5 } }, // Also checks for low pH
            conductivity: { id: "conductivity", label: "Conductivity", unit: "µS/cm", limits: { warning: 1500, danger: 5000 } }
        };
        
        const statusColors = {
            normal: '#38b2ac',
            warning: '#f97316',
            danger: '#ef4444'
        };

        const dashboardParameters = {
            main: ['temperature', 'cod', 'bod', 'tss', 'turbidity', 'ph', 'conductivity'],
            kandy: ['temperature', 'cod', 'bod', 'tss', 'turbidity'],
            galle: ['ph', 'conductivity']
        };

        /**
         * ## MODIFICATION: New function to determine gauge color status ##
         * Determines the status (normal, warning, danger) based on value and limits.
         */
        function getGaugeStatus(id, value, limits) {
            if (id === 'ph') {
                // pH has both high and low danger/warning zones
                if (value >= limits.danger || value <= (14 - limits.danger)) return 'danger';
                if (value >= limits.warning || value <= (14 - limits.warning)) return 'warning';
                return 'normal';
            }
            if (value >= limits.danger) return 'danger';
            if (value >= limits.warning) return 'warning';
            return 'normal';
        }

        function calculateGaugeFill(value, maxValue) {
            let percentage = (value / maxValue) * 100;
            if (percentage > 100) percentage = 100;
            if (percentage < 0) percentage = 0;
            return (percentage * 3.6);
        }

        /**
         * ## MODIFICATION: Updated gauge creation logic to use new design ##
         */
        function updateOrCreateGaugeCard(id, label, unit, value, limits) {
            let cardElement = document.getElementById(`${id}-gauge-card`);
            const fillAngle = calculateGaugeFill(value, maxValues[id]);
            const displayValue = (typeof value === 'number') ? value.toFixed(2) : '0.00';
            
            // ## MODIFICATION: Apply new color scheme ##
            let gaugeColorClass = '';
            if (id === 'ph' || id === 'conductivity') {
                gaugeColorClass = 'gauge-orange';
            } else {
                gaugeColorClass = 'gauge-green';
            }

            if (!cardElement) {
                const cardHtml = `
                    <div id="${id}-gauge-card" class="gauge-card shadow-lg ${gaugeColorClass}">
                        <div class="gauge-container">
                            <div class="gauge-fill" style="background: conic-gradient(var(--fill-color) ${fillAngle}deg, #e2e8f0 ${fillAngle}deg);"></div>
                            <div class="gauge-inner-circle">
                                <span class="gauge-value">${displayValue}</span>
                                <span class="gauge-unit">${unit}</span>
                            </div>
                        </div>
                        <div class="gauge-label text-gray-700">${label}</div>
                    </div>
                `;
                gaugesContainer.insertAdjacentHTML('beforeend', cardHtml);
            } else {
                const gaugeFill = cardElement.querySelector('.gauge-fill');
                const gaugeValueSpan = cardElement.querySelector('.gauge-value');
                
                if (gaugeFill) {
                    gaugeFill.style.background = `conic-gradient(var(--fill-color) ${fillAngle}deg, #e2e8f0 ${fillAngle}deg)`;
                }
                if (gaugeValueSpan) {
                    gaugeValueSpan.textContent = displayValue;
                }
            }
        }

        function updateOrCreateDeviceStatusCard(id, label, value, unit, isConnected) {
            let cardElement = document.getElementById(`${id}-device-card`);
            let contentHtml = (isConnected && typeof value === 'number')
                ? `<div class="value-display">${value.toFixed(2)} ${unit}</div>`
                : `<div class="disconnected-text">Disconnected</div>`;

            if (!cardElement) {
                const cardHtml = `
                    <div id="${id}-device-card" class="device-card" data-parameter="${id}">
                        <div class="device-name">${label} Sensor</div>
                        ${contentHtml}
                    </div>
                `;
                deviceStatusContainer.insertAdjacentHTML('beforeend', cardHtml);
                
                const newCard = document.getElementById(`${id}-device-card`);
                newCard.addEventListener('click', () => {
                    showGraph(id, label);
                });
            } else {
                cardElement.innerHTML = `
                    <div class="device-name">${label} Sensor</div>
                    ${contentHtml}
                `;
            }
        }

        function isDataRecent(timestamp) {
            if (!timestamp) return false;
            const apiTime = new Date(timestamp);
            const currentTime = new Date();
            return (currentTime - apiTime) / 1000 < 15;
        }

        async function fetchData() {
            let latestData = {};
            const dataSourcesStatus = { main: false, galle: false, conductivity: false };

            try {
                const fetchPromises = [];
                if (['main', 'kandy'].includes(currentDashboardView)) {
                    fetchPromises.push(fetch(backendUrlMain).then(res => res.json()).then(data => ({ source: 'main', data })));
                }
                if (['main', 'galle'].includes(currentDashboardView)) {
                    fetchPromises.push(fetch(backendUrlGalle).then(res => res.json()).then(data => ({ source: 'galle', data })));
                }
                if (['main', 'galle'].includes(currentDashboardView)) {
                    fetchPromises.push(fetch(backendUrlConductivity).then(res => res.json()).then(data => ({ source: 'conductivity', data })));
                }

                const results = await Promise.allSettled(fetchPromises);
                results.forEach(result => {
                    if (result.status === 'fulfilled') {
                        const { source, data } = result.value;
                        if (isDataRecent(data.timestamp)) {
                            dataSourcesStatus[source] = true;
                            latestData = { ...latestData, ...data };
                        }
                    }
                });
            } catch (error) {
                console.error("Error fetching data:", error);
            }
            
            deviceStatusContainer.innerHTML = '';
            gaugesContainer.innerHTML = '';

            const paramsToDisplay = dashboardParameters[currentDashboardView] || [];
            const anyDataIsRecent = Object.values(dataSourcesStatus).some(status => status);

            // ## MODIFICATION: Improved handling for disconnected state ##
            if (!anyDataIsRecent && paramsToDisplay.length > 0) {
                // Show individual sensor status instead of general offline message
                paramsToDisplay.forEach(paramId => {
                    const info = parameterInfo[paramId];
                    updateOrCreateDeviceStatusCard(info.id, info.label, 0, info.unit, false);
                    updateOrCreateGaugeCard(info.id, info.label, info.unit, 0, info.limits);
                });
                return;
            }

            paramsToDisplay.forEach(paramId => {
                const info = parameterInfo[paramId];
                const source = (paramId === 'ph') ? 'galle' : (paramId === 'conductivity' ? 'conductivity' : 'main');
                const isRecent = dataSourcesStatus[source];
                const value = (isRecent && latestData[info.id] !== undefined) ? parseFloat(latestData[info.id]) : 0;

                updateOrCreateDeviceStatusCard(info.id, info.label, value, info.unit, isRecent);
                updateOrCreateGaugeCard(info.id, info.label, info.unit, isRecent ? value : 0, info.limits);
            });
        }

        /**
         * ## MODIFICATION: New function to fetch and parse all historical data at once ##
         */
        async function fetchAllHistoricalData() {
            try {
                const [kandyResponse, galleResponse, conductivityResponse] = await Promise.all([
                    fetch("https://api.prudex.net/download"),
                    fetch("https://api1.prudex.net/download"),
                    fetch("https://api2.prudex.net/download")
                ]);
                const kandyText = await kandyResponse.text();
                const galleText = await galleResponse.text();
                const conductivityText = await conductivityResponse.text();

                const kandyData = Papa.parse(kandyText, { header: true, skipEmptyLines: true }).data;
                const galleData = Papa.parse(galleText, { header: true, skipEmptyLines: true }).data;
                const conductivityData = Papa.parse(conductivityText, { header: true, skipEmptyLines: true }).data;

                // Combine data, assuming timestamps are the key
                const combinedData = {};
                [...kandyData, ...galleData, ...conductivityData].forEach(row => {
                    if (row.timestamp) {
                        if (!combinedData[row.timestamp]) {
                            combinedData[row.timestamp] = {};
                        }
                        Object.assign(combinedData[row.timestamp], row);
                    }
                });
                
                historicalData = Object.values(combinedData).map(row => ({
                    ...row,
                    timestamp: new Date(row.timestamp)
                })).sort((a, b) => a.timestamp - b.timestamp);

            } catch (error) {
                console.error("Error fetching historical data:", error);
                historicalData = [];
            }
        }

        /**
         * ## MODIFICATION: New function to show the redesigned graph modal ##
         */
        function showGraph(parameterId, parameterLabel) {
            modalTitle.textContent = `${parameterLabel} - Historical Data`;
            historyModal.dataset.parameter = parameterId;
            
            // Reset alerts mode
            isAlertsMode = false;
            const alertsButton = document.getElementById('alerts-button');
            alertsButton.classList.remove('active');
            alertsButton.textContent = 'Alerts';
            
            // Reset all buttons to inactive state first
            filterButtons.forEach(button => {
                button.classList.remove('active');
            });
            
            // Set 1 Hour button as active by default
            const oneHourButton = document.querySelector('button[data-hours="1"]');
            if (oneHourButton) {
                oneHourButton.classList.add('active');
            }
            
            // Reset inputs to empty on open (fresh view)
            const alertMinInputEl = document.getElementById('alert-min');
            const alertMaxInputEl = document.getElementById('alert-max');
            customAlertMin = null;
            customAlertMax = null;
            alertMinInputEl.value = '';
            alertMaxInputEl.value = '';
            
            updateChart(1, 'hours'); // Default to 1 hour view
            historyModal.classList.add('show');
        }

        /**
         * ## MODIFICATION: New function to update the chart with filtered data ##
         */
        function updateChart(timeValue, timeUnit = 'days') {
            const parameterId = historyModal.dataset.parameter;
            if (!parameterId || historicalData.length === 0) return;

            const now = new Date();
            let cutoffDate;
            
            if (timeUnit === 'hours') {
                cutoffDate = new Date(now.getTime() - (timeValue * 60 * 60 * 1000));
            } else {
                cutoffDate = new Date(now.getTime() - (timeValue * 24 * 60 * 60 * 1000));
            }

            let filteredData = historicalData.filter(row => 
                row.timestamp >= cutoffDate && row[parameterId] !== undefined && row[parameterId] !== ''
            );

            // If alerts mode is active, filter for out-of-range data only (supports custom thresholds)
            if (isAlertsMode) {
                filteredData = filteredData.filter(row => {
                    const value = parseFloat(row[parameterId]);
                    const limits = parameterInfo[parameterId].limits;
                    const minThresh = (customAlertMin !== null) ? customAlertMin : (parameterId === 'ph' ? (14 - limits.warning) : -Infinity);
                    const maxThresh = (customAlertMax !== null) ? customAlertMax : limits.warning;
                    
                    if (parameterId === 'ph') {
                        // pH has high and low zones
                        const high = (customAlertMax !== null ? value >= maxThresh : value >= limits.warning);
                        const low = (customAlertMin !== null ? value <= minThresh : value <= (14 - limits.warning));
                        return high || low;
                    } else {
                        // Others: only high by default; include low if custom min provided
                        const high = (customAlertMax !== null ? value >= maxThresh : value >= limits.warning);
                        const low = (customAlertMin !== null ? value <= minThresh : false);
                        return high || low;
                    }
                });
            }

            if (historyChart) {
                historyChart.destroy();
            }

            // Choose x-axis unit dynamically so 7/30 day views show dates on X axis
            const xUnit = (timeUnit === 'days') ? (timeValue >= 7 ? 'day' : 'hour') : 'hour';

            const ctx = document.getElementById('history-chart').getContext('2d');
            historyChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: filteredData.map(row => row.timestamp),
                    datasets: [{
                        label: isAlertsMode ? `${parameterInfo[parameterId].label} - Alerts` : parameterInfo[parameterId].label,
                        data: filteredData.map(row => parseFloat(row[parameterId])),
                        borderColor: isAlertsMode ? '#dc2626' : '#007bff',
                        backgroundColor: isAlertsMode ? 'rgba(220, 38, 38, 0.1)' : 'rgba(0, 123, 255, 0.1)',
                        borderWidth: 2,
                        pointRadius: isAlertsMode ? 4 : 2,
                        tension: 0.1,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: xUnit,
                                tooltipFormat: 'MMM d, yyyy, h:mm a',
                                displayFormats: { day: 'MMM d', hour: 'MMM d, h a' }
                            },
                            title: { display: true, text: 'Time' }
                        },
                        y: {
                            title: { display: true, text: `Value (${parameterInfo[parameterId].unit})` }
                        }
                    }
                }
            });
            
            // First, remove 'active' class from all buttons
            filterButtons.forEach(button => {
                button.classList.remove('active');
            });
            
            // Then, add 'active' class only to the selected button
            filterButtons.forEach(button => {
                if (timeUnit === 'hours' && button.dataset.hours && parseInt(button.dataset.hours) === timeValue) {
                    button.classList.add('active');
                } else if (timeUnit === 'days' && button.dataset.days && parseInt(button.dataset.days) === timeValue) {
                    button.classList.add('active');
                }
            });
            
            // Debug logging to help troubleshoot
            console.log(`Chart updated: ${timeValue} ${timeUnit}`);
            console.log(`Active button should be: ${timeValue} ${timeUnit}`);
        }

        /**
         * ## NEW: Function to toggle alerts mode ##
         */
        function toggleAlertsMode() {
            isAlertsMode = !isAlertsMode;
            const alertsButton = document.getElementById('alerts-button');
            
            if (isAlertsMode) {
                alertsButton.classList.add('active');
                alertsButton.textContent = 'Show All';
            } else {
                alertsButton.classList.remove('active');
                alertsButton.textContent = 'Alerts';
            }
            
            // Get current active time filter and update chart
            const activeButton = document.querySelector('.filter-buttons button.active');
            if (activeButton) {
                if (activeButton.dataset.hours) {
                    updateChart(parseInt(activeButton.dataset.hours), 'hours');
                } else if (activeButton.dataset.days) {
                    updateChart(parseInt(activeButton.dataset.days), 'days');
                }
            }
        }


        // --- Login/Logout & Page Setup Logic ---
        function showLoginPage() {
            loginPage.classList.remove("hidden");
            dashboardContent.classList.add("hidden");
            clearInterval(fetchDataInterval);
        }
        function showDashboardPage() {
            dashboardContent.classList.remove("hidden");
            
            fetchData();
            clearInterval(fetchDataInterval);
            fetchDataInterval = setInterval(fetchData, 5000);
            fetchAllHistoricalData(); // Fetch historical data on login
        }

        // Login handler
        loginButton.addEventListener("click", () => {
            const username = (document.getElementById("username").value || '').trim().toLowerCase();
            const password = (document.getElementById("password").value || '').trim();
            if (username === "admin" && password === "2025") {
                document.getElementById("login-error-message").classList.add("hidden");
                showDashboardPage();
                loginPage.classList.add("hidden");
            } else {
                const msg = document.getElementById("login-error-message");
                msg.textContent = "Invalid username or password.";
                msg.classList.remove("hidden");
            }
        });

        // Allow pressing Enter to submit login
        [document.getElementById("username"), document.getElementById("password")].forEach(el => {
            el.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    loginButton.click();
                }
            });
        });

        // Logout reloads to show login again
        logoutButton.addEventListener("click", () => { window.location.reload(); });

        function setDashboardView(view) {
            currentDashboardView = view;
            const viewTitle = view.charAt(0).toUpperCase() + view.slice(1);
            dashboardMainTitle.textContent = `Factory X ${viewTitle} Dashboard`;
            fetchData();
            dashboardDropdownContent.classList.remove('show');
        }

        dashboardNavButton.addEventListener("click", (e) => {
            e.stopPropagation();
            dashboardDropdownContent.classList.toggle('show');
        });

        downloadNavButton.addEventListener("click", (e) => {
            e.stopPropagation();
            downloadDropdownContent.classList.toggle('show');
        });

        // Ask PrudeX open
        askPrudexButton.addEventListener('click', (e) => {
            e.stopPropagation();
            askInput.value = '';
            askModal.classList.add('show');
        });

        document.addEventListener('click', (e) => {
            if (!dashboardNavButton.contains(e.target)) dashboardDropdownContent.classList.remove('show');
            if (!downloadNavButton.contains(e.target)) downloadDropdownContent.classList.remove('show');
        });

        dropdownItems.forEach(item => {
            if (item.dataset.dashboard) {
                item.addEventListener('click', (e) => {
                    e.preventDefault();
                    setDashboardView(e.target.dataset.dashboard);
                });
            }
        });

        // --- New Modal Event Listeners ---
        modalCloseButton.addEventListener('click', () => historyModal.classList.remove('show'));
        historyModal.addEventListener('click', (e) => {
            if (e.target === historyModal) historyModal.classList.remove('show');
        });
        filterButtons.forEach(button => {
            button.addEventListener('click', () => {
                if (button.dataset.hours) {
                    updateChart(parseInt(button.dataset.hours), 'hours');
                } else if (button.dataset.days) {
                    updateChart(parseInt(button.dataset.days), 'days');
                }
            });
        });

        // Add event listener for alerts button
        document.getElementById('alerts-button').addEventListener('click', () => {
            toggleAlertsMode();
        });

        // Threshold editor handlers
        const alertMinInput = document.getElementById('alert-min');
        const alertMaxInput = document.getElementById('alert-max');
        const applyAlertBtn = document.getElementById('apply-alert-thresholds');
        const clearAlertBtn = document.getElementById('clear-alert-thresholds');

        function refreshChartForThresholds() {
            // keep current time filter
            const activeButton = document.querySelector('.filter-buttons button.active');
            if (activeButton) {
                if (activeButton.dataset.hours) {
                    updateChart(parseInt(activeButton.dataset.hours), 'hours');
                } else if (activeButton.dataset.days) {
                    updateChart(parseInt(activeButton.dataset.days), 'days');
                }
            } else {
                updateChart(1, 'hours');
            }
        }

        applyAlertBtn.addEventListener('click', () => {
            const minVal = alertMinInput.value.trim();
            const maxVal = alertMaxInput.value.trim();
            customAlertMin = minVal === '' ? null : parseFloat(minVal);
            customAlertMax = maxVal === '' ? null : parseFloat(maxVal);
            const pid = historyModal.dataset.parameter;
            isAlertsMode = true; // switch to alerts view when applying
            document.getElementById('alerts-button').classList.add('active');
            document.getElementById('alerts-button').textContent = 'Show All';
            refreshChartForThresholds();
        });

        // Removed 'Save Range' button; Safe Range is descriptive label only

        clearAlertBtn.addEventListener('click', () => {
            customAlertMin = null;
            customAlertMax = null;
            alertMinInput.value = '';
            alertMaxInput.value = '';
            const pid = historyModal.dataset.parameter;
            customThresholds[pid] = { min: null, max: null };
            refreshChartForThresholds();
        });

        // Ask PrudeX handlers
        askCloseButton.addEventListener('click', () => askModal.classList.remove('show'));
        askModal.addEventListener('click', (e) => { if (e.target === askModal) askModal.classList.remove('show'); });
        askSubmit.addEventListener('click', () => handleAsk());
        askInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') handleAsk(); });

        async function handleAsk() {
            const question = (askInput.value || '').trim();
            if (!question) return;
            appendChat('user', question);
            askInput.value = '';

            // Local analysis only
            const thinkingId = appendChat('assistant', '<span class="typing-dots"><span></span><span></span><span></span></span>');
            try {
                const answerText = answerQuestion(question);
                replaceChat(thinkingId, answerText);
            } catch (err) {
                const message = (err && err.message) ? err.message : 'Unknown error';
                replaceChat(thinkingId, `Sorry, I could not process that. (${message})`);
            }
        }

        function appendChat(role, content) {
            const wrapper = document.createElement('div');
            wrapper.style.marginBottom = '12px';
            const bubble = document.createElement('div');
            bubble.style.display = 'inline-block';
            bubble.style.padding = '12px 14px';
            bubble.style.borderRadius = '14px';
            bubble.style.maxWidth = '90%';
            bubble.style.whiteSpace = 'pre-wrap';
            bubble.style.wordBreak = 'break-word';
            bubble.classList.add('chat-bubble');
            if (role === 'user') bubble.classList.add('chat-bubble-user');
            else bubble.classList.add('chat-bubble-assistant');
            bubble.innerHTML = content;
            wrapper.appendChild(bubble);
            askChat.appendChild(wrapper);
            askChat.scrollTop = askChat.scrollHeight;
            const id = `chat-${Date.now()}-${Math.random().toString(36).slice(2)}`;
            wrapper.dataset.id = id;
            return id;
        }

        function replaceChat(id, newContent) {
            const node = Array.from(askChat.children).find(el => el.dataset && el.dataset.id === id);
            if (!node) return;
            const bubble = node.firstChild;
            if (bubble) bubble.innerHTML = newContent;
        }

        // --- Local Q&A analytics ---
        function parseTimeWindow(question) {
            const hoursMatch = question.match(/last\s+(\d+)\s*hour/i);
            const daysMatch = question.match(/last\s+(\d+)\s*day/i);
            const weekMatch = question.match(/last\s+(\d+)\s*week/i);
            const monthMatch = question.match(/last\s+(\d+)\s*month/i);
            if (hoursMatch) return { amount: parseInt(hoursMatch[1]), unit: 'hours' };
            if (daysMatch) return { amount: parseInt(daysMatch[1]), unit: 'days' };
            if (weekMatch) return { amount: parseInt(weekMatch[1]) * 7, unit: 'days' };
            if (monthMatch) return { amount: parseInt(monthMatch[1]) * 30, unit: 'days' };
            // default: all time (no limit)
            return null;
        }

        function filterByTimeWindow(data, windowSpec) {
            const now = new Date();
            if (!windowSpec) return data;
            const cutoff = new Date(now.getTime() - (windowSpec.unit === 'hours' ? windowSpec.amount * 3600000 : windowSpec.amount * 86400000));
            return data.filter(row => row.timestamp && row.timestamp >= cutoff);
        }

        function formatWhenText(windowSpec, specificDate) {
            if (specificDate) return specificDate.toLocaleDateString();
            if (!windowSpec) return 'all time';
            return `last ${windowSpec.amount} ${windowSpec.unit}`;
        }

        function parseSpecificDate(question) {
            const ymd = question.match(/(\d{4})[\/-](\d{2})[\/-](\d{2})/);
            if (ymd) {
                const y = parseInt(ymd[1]);
                const m = parseInt(ymd[2]) - 1;
                const d = parseInt(ymd[3]);
                return new Date(y, m, d);
            }
            const dmy = question.match(/(\d{2})[\/-](\d{2})[\/-](\d{4})/);
            if (dmy) {
                const d = parseInt(dmy[1]);
                const m = parseInt(dmy[2]) - 1;
                const y = parseInt(dmy[3]);
                return new Date(y, m, d);
            }
            return null;
        }

        function sameDay(a, b) {
            return a.getFullYear() === b.getFullYear() && a.getMonth() === b.getMonth() && a.getDate() === b.getDate();
        }

        function findParameterId(question) {
            const q = question.toLowerCase();
            for (const [id, info] of Object.entries(parameterInfo)) {
                if (q.includes(id) || q.includes(info.label.toLowerCase())) return id;
            }
            if (q.includes('conduct') || q.includes('ec')) return 'conductivity';
            return null;
        }

        function detectStatKind(question) {
            const q = question.toLowerCase();
            if (q.includes('highest') || q.includes('max')) return 'max';
            if (q.includes('lowest') || q.includes('min')) return 'min';
            if (q.includes('average') || q.includes('avg') || q.includes('mean')) return 'avg';
            return 'avg';
        }

        function computeStat(values, kind) {
            if (values.length === 0) return null;
            if (kind === 'max') return Math.max(...values);
            if (kind === 'min') return Math.min(...values);
            if (kind === 'avg') return values.reduce((a,b)=>a+b,0) / values.length;
            return null;
        }

        function parseThresholdSpec(question) {
            const q = question.toLowerCase();
            let comparator = null;
            if (q.includes('more than') || q.includes('greater than') || q.includes('above') || q.includes('over')) comparator = '>';
            if (q.includes('less than') || q.includes('below') || q.includes('under')) comparator = comparator || '<';
            if (q.includes('at least')) comparator = comparator || '>=';
            if (q.includes('at most')) comparator = comparator || '<=';
            if (q.includes('>=')) comparator = '>=';
            else if (q.includes('<=')) comparator = '<=';
            else if (q.includes('>')) comparator = comparator || '>';
            else if (q.includes('<')) comparator = comparator || '<';
            const numMatch = q.match(/(-?\d+\.?\d*)/);
            const value = numMatch ? parseFloat(numMatch[1]) : null;
            const paramId = findParameterId(question);
            if (!comparator || value === null || !paramId) return null;
            return { paramId, comparator, value };
        }

        function detectListIntent(question) {
            const q = question.toLowerCase();
            return q.includes('show') || q.includes('list') || q.includes('readings') || q.includes('events');
        }

        // Advanced analytics helpers
        function deviceColumnName(rows) {
            if (!rows || rows.length === 0) return null;
            const keys = Object.keys(rows[0]);
            const candidates = ['device', 'site', 'location', 'station'];
            return candidates.find(k => keys.includes(k)) || null;
        }

        function groupBy(rows, key) {
            const map = new Map();
            rows.forEach(r => {
                const k = r[key] || 'Unknown';
                if (!map.has(k)) map.set(k, []);
                map.get(k).push(r);
            });
            return map;
        }

        function groupByDay(rows, paramId) {
            const map = new Map();
            rows.forEach(r => {
                const d = r.timestamp; if (!d) return;
                const key = `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;
                const v = parseFloat(r[paramId]); if (isNaN(v)) return;
                if (!map.has(key)) map.set(key, []);
                map.get(key).push(v);
            });
            const result = [];
            for (const [day, vals] of map.entries()) {
                const avg = vals.reduce((a,b)=>a+b,0)/vals.length;
                result.push({ day, average: avg, count: vals.length });
            }
            result.sort((a,b)=> new Date(a.day) - new Date(b.day));
            return result;
        }

        function corrCoefficient(xs, ys) {
            const n = Math.min(xs.length, ys.length);
            if (n === 0) return null;
            const x = xs.slice(0, n); const y = ys.slice(0, n);
            const mean = arr => arr.reduce((a,b)=>a+b,0)/arr.length;
            const mx = mean(x), my = mean(y);
            let num = 0, dx=0, dy=0;
            for (let i=0;i<n;i++){ const vx=x[i]-mx; const vy=y[i]-my; num+=vx*vy; dx+=vx*vx; dy+=vy*vy; }
            const den = Math.sqrt(dx*dy);
            if (den === 0) return 0;
            return num/den;
        }

        function findRunsAbove(rows, paramId, threshold) {
            const runs = [];
            let current = [];
            rows.forEach(r => {
                const v = parseFloat(r[paramId]);
                if (!isNaN(v) && v > threshold) {
                    current.push(r);
                } else if (current.length) {
                    runs.push(current);
                    current = [];
                }
            });
            if (current.length) runs.push(current);
            return runs;
        }

        function getAlertStatus(paramId, value) {
            const limits = parameterInfo[paramId]?.limits;
            if (!limits || isNaN(value)) return 'normal';
            if (paramId === 'ph') {
                if (value >= limits.danger || value <= (14 - limits.danger)) return 'danger';
                if (value >= limits.warning || value <= (14 - limits.warning)) return 'warning';
                return 'normal';
            }
            if (value >= limits.danger) return 'danger';
            if (value >= limits.warning) return 'warning';
            return 'normal';
        }

        function getLastAlertTimestamp(paramId, severity = 'danger') {
            const rows = [...historicalData].filter(r => r[paramId] !== undefined && r[paramId] !== '');
            for (let i = rows.length - 1; i >= 0; i--) {
                const v = parseFloat(rows[i][paramId]);
                const status = getAlertStatus(paramId, v);
                if (status === severity || (severity === 'warning' && status !== 'normal')) {
                    return rows[i].timestamp;
                }
            }
            return null;
        }

        function answerQuestion(question) {
            if (!historicalData || historicalData.length === 0) {
                return 'No historical data loaded yet. Please wait a moment and try again.';
            }
            const q = question.toLowerCase();
            const specificDate = parseSpecificDate(q);
            const listIntent = detectListIntent(q) || q.includes('data');
            const paramId = findParameterId(q);

            // Date-only full listing: "show the data on YYYY/MM/DD" (no parameter)
            if (specificDate && listIntent && !paramId) {
                const dateRows = historicalData.filter(r => sameDay(r.timestamp, specificDate));
                if (dateRows.length === 0) return `No data on ${specificDate.toLocaleDateString()}.`;
                const lines = dateRows.map(r => {
                    const t = r.timestamp.toLocaleString();
                    const parts = Object.keys(r).filter(k => k !== 'timestamp').map(k => {
                        const raw = r[k];
                        if (raw === undefined || raw === '') return null;
                        const num = parseFloat(raw);
                        const val = !isNaN(num) ? num.toFixed(2) : String(raw);
                        return `${k}: ${val}`;
                    }).filter(Boolean);
                    return `• ${t} — ${parts.join(', ')}`;
                }).join('<br/>');
                return `${dateRows.length} readings on ${specificDate.toLocaleDateString()}:<br/>${lines}`;
            }
            if (!paramId) return 'Please specify a parameter (e.g., COD, pH, temperature).';

            // Current value / latest reading (optionally by device/location)
            if (q.includes('current') || q.includes('latest') || q.includes('right now')) {
                const dcol = deviceColumnName(historicalData);
                const latest = historicalData[historicalData.length - 1];
                const unit = parameterInfo[paramId].unit || '';
                if (dcol && (q.includes('device') || q.includes('location') || q.includes('site') || q.includes('station'))) {
                    const map = groupBy(historicalData, dcol);
                    const lines = [];
                    for (const [key, rows] of map.entries()) {
                        const lr = rows[rows.length - 1];
                        const v = parseFloat(lr[paramId]);
                        if (!isNaN(v)) lines.push(`• ${key}: ${v.toFixed(2)} ${unit} @ ${lr.timestamp.toLocaleString()}`);
                    }
                    if (lines.length) return `Latest ${parameterInfo[paramId].label} by ${dcol}:<br/>${lines.join('<br/>')}`;
                }
                if (latest && latest[paramId] !== undefined) {
                    const v = parseFloat(latest[paramId]);
                    if (!isNaN(v)) return `Latest ${parameterInfo[paramId].label}: ${v.toFixed(2)} ${unit} @ ${latest.timestamp.toLocaleString()}`;
                }
                return 'No recent data available.';
            }

            // Last alarm queries (e.g., "when was the last pH alarm")
            if (q.includes('last alarm') || q.includes('last alert')) {
                const ts = getLastAlertTimestamp(paramId, 'danger');
                if (!ts) return `No ${parameterInfo[paramId].label} danger alarms found.`;
                return `Last ${parameterInfo[paramId].label} alarm: ${ts.toLocaleString()}`;
            }

            // Threshold queries (e.g., over/below X)
            const thresholdSpec = parseThresholdSpec(q);
            const windowSpec = specificDate ? { amount: 36500, unit: 'days' } : parseTimeWindow(q);
            const inWindow = filterByTimeWindow(historicalData, windowSpec);
            const dataRows = specificDate ? inWindow.filter(r => sameDay(r.timestamp, specificDate)) : inWindow;

            if (thresholdSpec && thresholdSpec.paramId === paramId) {
                const { comparator, value } = thresholdSpec;
                const matches = dataRows.filter(r => {
                    const v = parseFloat(r[paramId]);
                    if (isNaN(v)) return false;
                    if (comparator === '>') return v > value;
                    if (comparator === '>=') return v >= value;
                    if (comparator === '<') return v < value;
                    if (comparator === '<=') return v <= value;
                    if (comparator === '==') return v === value;
                    return false;
                });
                const unit = parameterInfo[paramId].unit || '';
                const whenText = formatWhenText(windowSpec, specificDate);
                if (matches.length === 0) return `No ${parameterInfo[paramId].label} readings ${comparator} ${value} ${unit} in ${whenText}.`;
                const lines = matches.map(r => `• ${r.timestamp.toLocaleString()} — ${parseFloat(r[paramId]).toFixed(2)} ${unit}`).join('<br/>');
                return `${matches.length} ${parameterInfo[paramId].label} readings ${comparator} ${value} ${unit} in ${whenText}:<br/>${lines}`;
            }

            // Exceedance periods (e.g., turbidity exceeded safe limits)
            if (q.includes('exceeded') || q.includes('exceed') || q.includes('safe limit')) {
                const limit = parameterInfo[paramId]?.limits?.warning ?? null;
                if (limit === null) return 'No threshold configured for this parameter.';
                const runs = findRunsAbove(dataRows, paramId, limit);
                if (runs.length === 0) return `No periods where ${parameterInfo[paramId].label} exceeded ${limit}.`;
                const summaries = runs.map(run => `${run[0].timestamp.toLocaleString()} → ${run[run.length-1].timestamp.toLocaleString()} (${run.length} points)`);
                return `Periods where ${parameterInfo[paramId].label} exceeded ${limit}:<br/>${summaries.map(s => '• ' + s).join('<br/>')}`;
            }

            // Correlation (e.g., compare ORP vs pH, temperature vs COD)
            if (q.includes('correlation') || q.includes('compare')) {
                const otherParamCandidates = ['ph','orp','cod','bod','tss','turbidity','temperature','conductivity'];
                const other = otherParamCandidates.find(p => p !== paramId && q.includes(p));
                const otherId = other || null;
                if (!otherId || !parameterInfo[otherId]) return 'Second parameter not found for correlation.';
                const xs = dataRows.map(r => parseFloat(r[paramId])).filter(v => !isNaN(v));
                const ys = dataRows.map(r => parseFloat(r[otherId])).filter(v => !isNaN(v));
                const rcoef = corrCoefficient(xs, ys);
                if (rcoef === null) return 'Insufficient data for correlation.';
                return `Correlation between ${parameterInfo[paramId].label} and ${parameterInfo[otherId].label} in last ${windowSpec.amount} ${windowSpec.unit}: r = ${rcoef.toFixed(3)}.`;
            }

            // Daily averages
            if (q.includes('daily average') || (q.includes('calculate') && q.includes('daily'))) {
                const grouped = groupByDay(dataRows, paramId);
                if (grouped.length === 0) return 'No data available.';
                const unit = parameterInfo[paramId].unit || '';
                const lines = grouped.map(g => `• ${g.day} — ${g.average.toFixed(2)} ${unit} (${g.count} pts)`).join('<br/>' );
                return `Daily averages for ${parameterInfo[paramId].label}:<br/>${lines}`;
            }

            // Rank by device/location (e.g., rank devices by average conductivity)
            if (q.includes('rank') || q.includes('highest') || q.includes('by average')) {
                const dcol = deviceColumnName(dataRows);
                if (!dcol) return 'No device/location column found.';
                const map = groupBy(dataRows, dcol);
                const stats = [];
                for (const [key, rows] of map.entries()) {
                    const vals = rows.map(r => parseFloat(r[paramId])).filter(v => !isNaN(v));
                    if (vals.length === 0) continue;
                    const avg = vals.reduce((a,b)=>a+b,0)/vals.length;
                    stats.push({ key, avg });
                }
                stats.sort((a,b)=> b.avg - a.avg);
                if (stats.length === 0) return 'No data available.';
                const unit = parameterInfo[paramId].unit || '';
                const lines = stats.map(s => `• ${s.key}: ${s.avg.toFixed(2)} ${unit}`).join('<br/>' );
                return `Average ${parameterInfo[paramId].label} by ${dcol} (desc):<br/>${lines}`;
            }

            // Count queries (e.g., how many cod points)
            if (q.includes('how many')) {
                const count = dataRows.filter(r => r[paramId] !== undefined && r[paramId] !== '' && !isNaN(parseFloat(r[paramId]))).length;
                const whenText = formatWhenText(windowSpec, specificDate);
                return `${count} ${parameterInfo[paramId].label} data points in ${whenText}.`;
            }

            // Stats queries (max/min/avg)
            const kind = detectStatKind(q);
            const values = dataRows.map(r => parseFloat(r[paramId])).filter(v => !isNaN(v));
            const stat = computeStat(values, kind);
            if (stat === null) return 'No data available for that query.';
            const unit = parameterInfo[paramId].unit || '';
            const whenText = formatWhenText(windowSpec, specificDate);
            return `${kind.toUpperCase()} ${parameterInfo[paramId].label} in ${whenText}: <strong>${stat.toFixed(2)} ${unit}</strong> (from ${values.length} data points).`;
        }

        // Removed local Q&A parsing and statistics; delegating answers to Ask PrudeX backend

        function parseThresholdSpec(question) {
            const q = question.toLowerCase();
            // detect comparator phrases
            let comparator = null;
            if (q.includes('more than') || q.includes('greater than') || q.includes('above')) comparator = '>';
            if (q.includes('less than') || q.includes('below')) comparator = comparator || '<';
            if (q.includes('at least')) comparator = comparator || '>=';
            if (q.includes('at most')) comparator = comparator || '<=';
            // symbolic comparators
            if (q.includes('>=')) comparator = '>=';
            else if (q.includes('<=')) comparator = '<=';
            else if (q.includes('>')) comparator = '>';
            else if (q.includes('<')) comparator = '<';

            // extract number
            const numMatch = q.match(/(-?\d+\.?\d*)/);
            const value = numMatch ? parseFloat(numMatch[1]) : null;
            const paramId = findParameterId(question);
            if (!comparator || value === null || !paramId) return null;
            return { paramId, comparator, value };
        }



        // Start at login
        showLoginPage();

    </script>
</body>
</html>
</html>
