<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Factory X Main Dashboard</title>
    <!-- Tailwind CSS CDN for modern styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts - Inter for a clean, modern look -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        /* Base styles for the body, setting a light background and text color */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5; /* Light white background for the page */
            color: #333; /* Darker text for better readability on light background */
            text-align: center;
            padding: 20px;
        }
        /* Styling for the main heading with a vibrant gradient */
        h1 {
            margin-bottom: 30px;
        }

        /* Glassy effect for the data panels (sections) */
        .glass-panel {
            background: rgba(255, 255, 255, 0.3); /* Translucent white background */
            backdrop-filter: blur(10px); /* Creates the blur effect behind the element */
            border: 1px solid rgba(255, 255, 255, 0.5); /* Lighter border for definition */
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.1); /* Soft shadow for depth */
            border-radius: 15px; /* Rounded corners for a modern look */
            padding: 20px;
            margin-bottom: 25px; /* Spacing between sections */
        }

        /* Styles for the individual gauge cards (Live Readings) */
        .gauge-card {
            display: flex; /* Use flexbox for centering content inside */
            flex-direction: column; /* Stack items vertically */
            align-items: center; /* Center items horizontally */
            justify-content: center; /* Center items vertically */
            background: rgba(255, 255, 255, 0.3); /* Translucent white background */
            backdrop-filter: blur(10px); /* Creates the blur effect behind the element */
            border: 1px solid rgba(255, 255, 255, 0.5); /* Lighter border for definition */
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.1); /* Soft shadow for depth */
            border-radius: 15px; /* Rounded corners for a modern look */
            padding: 20px;
            margin: 10px; /* Provides spacing when not in a grid */
            min-width: 180px; /* Ensures cards have a minimum width for layout */
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out; /* Smooth transition on hover */
            text-align: center; /* Ensures text inside is centered */
        }
        /* Hover effect for gauge cards */
        .gauge-card:hover {
            transform: translateY(-5px); /* Slightly lift the card on hover */
            box-shadow: 0 12px 48px 0 rgba(0, 0, 0, 0.15); /* More pronounced shadow on hover */
        }

        /* Styles for the circular gauges itself */
        .gauge-container {
            position: relative;
            width: 120px; /* Fixed width for the outer circle of the gauge */
            height: 120px; /* Fixed height for the outer circle of the gauge */
            border-radius: 50%; /* Makes the container circular */
            /* Default background for the gauge, a gray base circle */
            background: conic-gradient(#e2e8f0 0deg, #e2e8f0 360deg);
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 10px;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.1); /* Inner shadow for depth */
        }
        /* Inner circle of the gauge to create the "hole" effect */
        .gauge-inner-circle {
            width: 90px; /* Smaller width for the inner circle */
            height: 90px; /* Smaller height for the inner circle */
            border-radius: 50%; /* Makes the inner circle circular */
            background-color: #f0f2f5; /* Matches body background to create a hollow effect */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem; /* Larger font for the value inside the gauge */
            font-weight: bold;
            color: #333; /* Dark text for the value */
        }
        /* Label for each gauge (e.g., Temperature, COD) */
        .gauge-label {
            font-size: 0.9em;
            color: #555;
            margin-top: 5px;
            font-weight: 600;
        }
        /* Unit for each gauge */
        .gauge-unit {
            font-size: 0.7em;
            color: #777;
            font-weight: normal;
        }


        /* Dynamic gauge fill colors using conic-gradient for a progress effect */
        /* The --fill-angle variable is set by JavaScript to control the progress */
        .gauge-fill-temp { background: conic-gradient(from 0deg, #38b2ac var(--fill-angle), #e2e8f0 var(--fill-angle)); } /* Teal */
        .gauge-fill-cod { background: conic-gradient(from 0deg, #ef4444 var(--fill-angle), #e2e8f0 var(--fill-angle)); } /* Red */
        .gauge-fill-bod { background: conic-gradient(from 0deg, #f97316 var(--fill-angle), #e2e8f0 var(--fill-angle)); } /* Orange */
        .gauge-fill-tss { background: conic-gradient(from 0deg, #6366f1 var(--fill-angle), #e2e8f0 var(--fill-angle)); } /* Indigo */
        .gauge-fill-turbidity { background: conic-gradient(from 0deg, #10b981 var(--fill-angle), #e2e8f0 var(--fill-angle)); } /* Emerald */

        /* Device status card styling - now with glassy effect */
        .device-card {
            background: rgba(255, 255, 255, 0.3); /* Translucent white background */
            backdrop-filter: blur(10px); /* Creates the blur effect behind the element */
            border: 1px solid rgba(255, 255, 255, 0.5); /* Lighter border for definition */
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.1); /* Soft shadow for depth */
            border-radius: 15px; /* Rounded corners for a modern look */
            padding: 15px;
            display: flex;
            flex-direction: column;
            align-items: flex-start; /* Align text to the left */
            text-align: left;
            position: relative;
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out; /* Smooth transition on hover */
        }
        .device-card:hover {
            transform: translateY(-5px); /* Slightly lift the card on hover */
            box-shadow: 0 12px 48px 0 rgba(0, 0, 0, 0.15); /* More pronounced shadow on hover */
        }

        /* Removed status-badge as per user request */
        /* .status-badge { ... } */

        .device-name {
            font-size: 1.1em;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 5px;
        }
        .value-display { /* Style for the value within the device status card */
            font-size: 1.5em; /* Larger font for the value */
            font-weight: bold;
            color: #333; /* Dark text */
            margin-top: 5px; /* Spacing from device name */
        }
        .disconnected-text { /* Style for "Disconnected" text when data is old */
            font-size: 1.3em; /* Slightly larger for emphasis */
            font-weight: bold;
            color: #dc2626; /* Red color for disconnected status */
            margin-top: 5px; /* Spacing from device name */
        }
    </style>
</head>
<body>
    <div class="container mx-auto p-4 max-w-7xl">
        <!-- Main heading with a gradient text effect -->
        <h1 class="text-4xl font-extrabold text-transparent bg-clip-text bg-gradient-to-r from-blue-600 to-cyan-500">
            Factory X Main Dashboard
        </h1>

        <!-- Device Status Section -->
        <div class="glass-panel">
            <h2 class="text-2xl font-semibold mb-6 text-gray-700 text-left">
                Device Status
            </h2>
            <div id="device-status-container" class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-6 justify-center">
                <!-- Device Status Cards will be dynamically inserted here -->
            </div>
        </div>

        <!-- Live Readings Section -->
        <div class="glass-panel">
            <h2 class="text-2xl font-semibold mb-6 text-gray-700 text-left">
                Live Readings
            </h2>
            <div id="gauges-container" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-5 gap-6 justify-center">
                <!-- Gauge Cards will be dynamically inserted here by JavaScript -->
            </div>
        </div>
    </div>

    <script>
        // API endpoint for fetching data
        const backendUrl = "https://api.prudex.net/latest";

        // DOM element references
        const deviceStatusContainer = document.getElementById("device-status-container");
        const gaugesContainer = document.getElementById("gauges-container");

        // Define maximum values for each parameter for gauge scaling
        // These values can be adjusted based on sensor capabilities or water quality standards
        const maxValues = {
            temperature: 50,    // Max typical temperature for water monitoring
            cod: 500,           // Max COD for general wastewater/industrial effluent
            bod: 300,           // Max BOD for general wastewater/industrial effluent
            tss: 300,           // Max TSS
            turbidity: 1000     // Max Turbidity
        };

        // Map backend keys to display names and units for both sections
        const parameterInfo = {
            temperature: { label: "Temperature", unit: "°C" },
            cod: { label: "COD", unit: "mg/L" },
            bod: { label: "BOD", unit: "mg/L" },
            tss: { label: "TSS", unit: "mg/L" },
            turbidity: { label: "Turbidity", unit: "NTU" },
        };

        /**
         * Calculates the fill percentage as an angle (0-360 degrees) for a circular gauge.
         * The value is capped between 0 and 100% relative to the maxValue.
         * @param {number} value - The current reading value.
         * @param {number} maxValue - The maximum expected value for the gauge.
         * @returns {string} - The angle in degrees (e.g., "180.0") as a string.
         */
        function calculateGaugeFill(value, maxValue) {
            let percentage = (value / maxValue) * 100;
            if (percentage > 100) percentage = 100; // Cap at 100% to prevent overfilling
            if (percentage < 0) percentage = 0;   // Ensure non-negative percentage
            return (percentage * 3.6).toFixed(1); // Converts percentage to degrees (360 deg / 100%)
        }

        /**
         * Generates the HTML string for a single gauge card.
         * @param {string} id - A unique identifier for the specific metric (e.g., 'temperature').
         * @param {string} label - The human-readable label for the gauge (e.g., 'Temperature').
         * @param {string} unit - The unit of measurement (e.g., '°C').
         * @param {number | string} value - The current reading value. Can be 'N/A' if data is missing.
         * @param {string} fillClass - The CSS class that defines the vibrant fill color for the gauge.
         * @returns {string} - The complete HTML string for the gauge card.
         */
        function createGaugeCard(id, label, unit, value, fillClass) {
            // Calculate the fill angle only if the value is a valid number
            const fillAngle = (typeof value === 'number') ? calculateGaugeFill(value, maxValues[id]) : '0';
            // Gauges should show two decimal places as requested
            const displayValue = (typeof value === 'number') ? value.toFixed(2) : 'N/A';

            return `
                <div id="${id}-gauge-card" class="gauge-card shadow-lg flex-1 min-w-40 max-w-xs">
                    <div class="gauge-container ${fillClass}" style="--fill-angle: ${fillAngle}deg;">
                        <div class="gauge-inner-circle">
                            <span id="${id}-value">${displayValue}</span>
                            <span class="gauge-unit">${unit}</span>
                        </div>
                    </div>
                    <div class="gauge-label text-gray-700">${label}</div>
                </div>
            `;
        }

        /**
         * Generates the HTML string for a single device status card, showing parameter name, value, and connectivity.
         * @param {string} label - The display label for the sensor (e.g., 'Temperature Sensor').
         * @param {number | string} value - The current reading value. Can be 'N/A' if data is missing.
         * @param {string} unit - The unit of measurement (e.g., '°C').
         * @param {boolean} isConnected - True if the system is considered connected, false otherwise.
         * @returns {string} - The complete HTML string for the device status card.
         */
        function createDeviceStatusCard(label, value, unit, isConnected) {
            let contentHtml = '';
            // If connected, show the value with two decimal places. Otherwise, show "Disconnected".
            if (isConnected && typeof value === 'number') {
                const displayValue = value.toFixed(2); // Two decimal places for device status
                contentHtml = `<div class="value-display">${displayValue} ${unit}</div>`;
            } else {
                contentHtml = `<div class="disconnected-text">Disconnected</div>`;
            }

            return `
                <div class="device-card">
                    <div class="device-name">${label} Sensor</div>
                    ${contentHtml}
                    <!-- Removed status-badge as per user request -->
                </div>
            `;
        }

        /**
         * Fetches data from the backend API, updates the gauges, and updates device status.
         * Includes exponential backoff for robust API calls.
         */
        async function fetchData() {
            let response;
            let retries = 0;
            const maxRetries = 5; // Maximum number of retries
            const baseDelay = 1000; // 1 second base delay for exponential backoff
            let latestItem = null;

            try {
                // Attempt to fetch data with exponential backoff
                while (retries <= maxRetries) {
                    try {
                        response = await fetch(backendUrl);
                        if (response.ok) {
                            break; // Exit loop if fetch is successful
                        }
                    } catch (fetchError) {
                        console.error(`Fetch attempt ${retries + 1} failed:`, fetchError);
                    }

                    if (retries < maxRetries) {
                        const delay = baseDelay * Math.pow(2, retries);
                        console.warn(`Retrying fetch data in ${delay / 1000} seconds...`);
                        await new Promise(resolve => setTimeout(resolve, delay));
                    }
                    retries++;
                }

                if (!response || !response.ok) {
                    throw new Error(`Failed to fetch data after ${maxRetries} retries. Status: ${response ? response.status : 'N/A'}`);
                }

                const data = await response.json();

                if (Array.isArray(data)) {
                    latestItem = data[data.length - 1]; // Get the last item if data is an array
                } else {
                    latestItem = data; // If it's a single object, it's the latest
                }

            } catch (error) {
                console.error("Error fetching or processing data:", error);
                // If there's an error, latestItem remains null, which will trigger 'N/A' and 'Disconnected'
            }

            // Determine if the data is recent enough (within the last 30 seconds)
            let isDataRecent = false;
            if (latestItem && latestItem.timestamp) {
                // Parse timestamp and get current time
                const timestampMs = new Date(latestItem.timestamp).getTime();
                const currentTimeMs = Date.now(); // Current time in milliseconds

                // Check if the timestamp is within the last 30 seconds (30 * 1000 milliseconds)
                if ((currentTimeMs - timestampMs) / 1000 < 30) {
                    isDataRecent = true;
                }
            }

            // --- Update Device Status Section ---
            deviceStatusContainer.innerHTML = ""; // Clear existing status cards
            Object.keys(parameterInfo).forEach(key => {
                const info = parameterInfo[key];
                const value = latestItem && latestItem[key] !== undefined ? latestItem[key] : 'N/A';
                // Pass isDataRecent to determine if value or "Disconnected" is shown
                deviceStatusContainer.innerHTML += createDeviceStatusCard(info.label, value, info.unit, isDataRecent);
            });

            // --- Update Live Readings (Gauges) Section ---
            gaugesContainer.innerHTML = ""; // Clear existing gauge cards
            Object.keys(parameterInfo).forEach(key => {
                const info = parameterInfo[key];
                let valueForGauge = 'N/A';
                if (isDataRecent && latestItem && latestItem[key] !== undefined) {
                    valueForGauge = latestItem[key];
                } else {
                    // If data is not recent, or missing, show 0 on the gauge
                    valueForGauge = 0;
                }

                // Pass the appropriate fill class for each gauge
                let fillClass;
                if (key === 'temperature') fillClass = 'gauge-fill-temp';
                else if (key === 'cod') fillClass = 'gauge-fill-cod';
                else if (key === 'bod') fillClass = 'gauge-fill-bod';
                else if (key === 'tss') fillClass = 'gauge-fill-tss';
                else if (key === 'turbidity') fillClass = 'gauge-fill-turbidity';

                gaugesContainer.innerHTML += createGaugeCard(key, info.label, info.unit, valueForGauge, fillClass);
            });

            // Display a message if no real-time data is available for gauges
            if (!latestItem) {
                gaugesContainer.innerHTML = "<p class='text-red-500'>No real-time data available for key metrics. Check backend connection.</p>";
            }
        }

        // Call functions immediately when the window loads
        window.onload = function() {
            fetchData(); // Fetch and update all dashboard elements
        };

        // Set an interval to refresh the dynamic data every 5 seconds
        setInterval(fetchData, 5000);
    </script>
</body>
</html>
